--1.მოვნახოთ ყველა კლიენტი ვისაც გააჩნია როგორც სესხი ასევე დეპოზიტი.

SELECT distinct c.*,l.CustomerID, d.CustomerID--ბოლო ორი სვეტი გადამოწმებისთვის, რომ ნამდვილად სწორად მხოდა ჯოინი.
FROM Customers AS c
JOIN loan.loans AS l
ON c.CustomerID=l.CustomerID
JOIN Deposits AS d 
ON c.CustomerID=d.CustomerID
--მონახავს ყველა უნიკალურ კლიენტს რომლებსაც გააჩნიათ მინიმუმ ერთი სესხი და ერთი დეპოზიტი მაინც.
--ამისათვის ვიყენებთ INNER JOIN-ებს


--2.სესხებზე და დეპოზიტებზე გავაკეთოთ 4-ვე JOIN-ი და ავხსნათ რა გასხვავებულ შედეგს მოგვცემს თითეული.

--inner join
SELECT  l.*, d.*
FROM loan.Loans AS l
JOIN Deposits AS d
ON l.CustomerID=d.CustomerID
ORDER BY l.CustomerID
--თუ მომხმარებლის აიდი გამეორდება რამდენჯერმე როგორც სესხებში ასევე დეპოზიტებში, მაშინ ინერ ჯოინი მოგვცემს რაოდენობას,
--რომელიც იქნება ერთი ცხრილიდან თითოეული აიდის რაოდენობის ნამრავლი მეორე ცხრილში იგივე აიდის შეხვედრის რაოდენობაზე 
--და ეს ყველაფერი შეკრებილი თითოეული აიდისთვის.603

--left join
SELECT  l.*, d.*
FROM loan.Loans AS l
LEFT JOIN Deposits AS d
ON l.CustomerID=d.CustomerID
--WHERE d.CustomerID>0 --თუ მომხმარებლის აიდი მეტია 0-ზე გამოდის რომ ასეთი მომხმარებელი არსებობს , ანუ არის ვალიდური მონაცემი.
ORDER BY l.CustomerID
-- ამ შემთხვევაში გვექნება ზემოთ გამოტანილი ცხრილის სტრიქონების რაოდენობას დამატებული სესხების ცხრილიდან ისეთი ელემენტები,
-- რომლის შესაბამისობაც ვერ მოიძებნა დეპოზიტების ცხრილში(მომხმარებლის აიდის მიხედვით, ანუ მომხმარებლს ჰქონდა სესხები მაგრამ არ ჰქონია დეპოზიტი), 
--მაგრამ მაინც გამოიტანა და ასეთი ადგილები გადაავსო NULL-ებით
--პირველი სიმრავლე მთლიანად და დეპოზიტებიდან მხოლოდ სესხებთან თანაკვეთა, მომხმარებლის აიდის მიხედვით.1218
--თუ კომენტარს გავაუქმებთ და დეპოზიტების ცხრილიდან აღარ გამოვიყოლებთ null-იან სტრიქონებს მაშინ მივიღებთ საწყის მნიშვნელობას ანუ 603 კომბინაციას,
-- მაგრამ ყოველი მომხმარებლის აიდი მაინც არ იქნება უნიკალური

--right join
SELECT  l.*, d.*
FROM loan.Loans AS l
RIGHT JOIN Deposits AS d
ON l.CustomerID=d.CustomerID
--WHERE l.CustomerID >0
ORDER BY l.CustomerID
-- ამ შემთხვევაში გვექნება პირიქით, თუ მომხმარებელს აქვს დეპოზიტები მაგრამ არ აქვს სესხი, მაშინ სესხების ცხრილის ყოველი სვეტი,
-- დეპოზიტების ცხრილიდან მომხმარებლის აიდის სტრიქონის გაყოლებაზე გადაივსება NULL-ებით
-- ეს თავისებურებები გამომდინარეობს მარჯვენა ჯოინიდან, ანუ მარჯვენა ცხრილი არის პრიორიტეტული,
-- ჩვენ შემთხვევაში დეპოზიტების სიმრავლე და ამიტომ ასელექთებს მთლიანად.
--837
--თუ კომენტარს გავაუქმებთ და სესხების ცხრილიდან აღარ გამოვიყოლებთ null-იან სტრიქონებს მაშინ მივიღებთ საწყის მნიშვნელობას ანუ 603 კომბინაციას,
-- მაგრამ ყოველი მომხმარებლის აიდი მაინც არ იქნება უნიკალური

--full join
SELECT  l.*, d.*
FROM loan.Loans AS l
FULL JOIN Deposits AS d
ON l.CustomerID=d.CustomerID
--WHERE l.CustomerID >0
ORDER BY l.CustomerID
-- FULL JOIN-ში მივიღეთ იმდენი სტრიქონი რაც იქნებოდა მარცხენა ჯოინის შედეგს დამატებული მარჯვენა ჯოინის შედეგი და დაკლებული მარცხენისა და მარჯვენა ჯოინის თანაკვეთა,
--რადგან თანაკვეთა შედის როგორც დეპოზიტებში ისევე სესხებში , ანუ მეორდება ორჯერ და თუ დავაკლებთ ერთ თანაკვეთას მივიღებთ FULL JOIN-ს 
-- FULL JOIN-ი თავის თავში გულისხმობს, რომ მოგვცეს ისეთი სტრიქონები სადაც მომხმარებელს აქვს ან სესხი, ან დეპოზიტი და ან ორივე ერთად, თუ არცერთი არ აქვს,
-- შესაბამისად ცხრილებიდან ვერ წამოიღებს ინფორმაციას , რადგან ჯოინი ხდება მხოლოდ და მხოლოდ მომხმარებლის აიდის მიხედვით.


--3.ავაწყოთ კომპლექსური ჯოინები, 4-5 ცხრილის დაკავშირებოთ (ცხრილებს მივანიჭოთ Alias-ები).

SELECT *FROM Customers as c
JOIN Accounts as a
on c.CustomerID=a.CustomerID
JOIN loan.LoanAccounts as la
on a.AccountID=la.AccountID
JOIN loan.Loans as l
on la.LoanID=l.LoanID
JOIN loan.Products as p
on l.ProductID=p.ProductID
--ორივე არის ერთი და იგივე
--ამ ჯოინების მეშვეობით გავიგებთ რომელმა მომხმარებელმა შეიძინა სესხით
--(აქ არ ვარ დარწმუნებული, მგონი loanaccount-ში იგულისხმება საკრედიტო ანგარიში და სწორედ ამ ანგარიშით მოხდა შეძენა) კონკრეტული პროდუქტი
SELECT*FROM Customers AS C
JOIN loan.Loans AS L
ON C.CustomerID=L.CustomerID
JOIN loan.Products as p
on l.ProductID=p.ProductID

------------------------------------------------
--4.
--სესხებსა და ანგარიშებს შორის კავშირი არის მრავალი მრავალთან
--რადგან დაკავშირება ხდება მესამე ცხრილის ამ შემთხვევაში მომხმარებლების აიდის მიხედვით
--ერთ მომხმარებელს შეიძლება ჰქონდეს როგორც მრავალი სესხი, ასევე მრავალი ანგარიში
--თუ ზემოთხსენებულ ორ ცხრილს დავაკავშირებთ, მაშინ მივიღებთ გადამრავლებული ჩანაწერების რაოდენობას
--დაჯგუფება ხდება სესხებიდან თითოეული მომხმარებლის მიხედვით იმდენ ჩანაწერთან რამდენჯერაც იგივე მომხმარებელი გვხვდება ანგარიშებში
SELECT *FROM loan.Loans AS L
JOIN Accounts AS a
ON L.CustomerID=A.CustomerID -- ერთ მომხმარებელს შეიძლება ჰქონდეს ერთზე მეტი სესხი
JOIN Customers AS C 
ON A.CustomerID= C.CustomerID
-- ასეთი დაჯოინება არ იქნება სწორი რადგან ვერ მივიღებთ ღირებულ ინფორმაციას


select* from Customers as c
join Accounts as a
on c.CustomerID=a.CustomerID
join OverDrafts as o
on a.AccountID=o.AccountID
-- ამ ჯოინით გამოვიტანთ ყველა ისეთი მომხმარებლის ანგარიშებს რომლებიც არიან ვადაგადაცილებაში,
-- ასევე დაასელექთებს მომხმარებლის სრულ ინფორმაციას და ანგარიშების ნომრებს


-------------------
select*from Transactions as t 
join TransactionTypes as tt
on t.TransactionTypeID=tt.TransactionTypeID
-- რა ტიპის არის თითოეული ტრანზაქცია


select * from Customers as c
join Accounts  as a
on c.CustomerID=a.CustomerID
join AccountTypes as t
on a.AccountTypeID=t.AccountTypeID
order by c.CustomerID
--მომხმარებლები და მათი ყველა ანგარიში , ანგარიშის ტიპებით

-----------------
--5.MyBank ბაზაზე ავაწყოთ ყველა შესაძლო PK-FK კავშირები და Screen-ების სახით
--გამომიგზანეთ. სადაც ნათლად გამოჩნდება რომელია Primary Key და foreign
--Key ცხრილები და ასევე PK და FK სვეტი.
-----------------



--6. ცხრილებს შორის კავშირები:

--Customers >> Accounts ერთი-მრავალთან
--Customers >> Loans ერთი-მრავალთან
--Loans >> LoanAccouns ერთი-ერთთან
--Customer >> Deposits ერთი-მრავალთან
--Accounts >> Overdrafts ერთი-მრავალთან
--Transactions >> Accounts მრავალი-მრავალთან
--TransactionTypes >> Transactions ერთი-მრავალთან

--7.დავუბრუნდეთ Join-ებს დავადგინოთ თითეული ტრანსაქციაში debit-ის და
--credit-ის ანგარიში ვის ეკუთვნის , ანუ რეზულტატში თითეულ ტრანზაქციას უნდა
--მიედგას ორ-ორი სახელი და გვარი, ერთი დებიტის ანგარიშის მფლობელის, მეორე
--კრედიტის.

select* from Customers as c
join Accounts as a
on c.CustomerID=a.CustomerID
join Transactions as t
on a.AccountID=t.DebitAccountID or a.AccountID=t.CreditAccountID
order by TransactionID
--თითოეული ტრანზაქცია დუბლირდება რადგან ერთი იქნება გადამრიცხავიდან მიმღებამდე
--მეორე კი პირიქით



--8.დავწეროთ ისეთი Query, რომელიც ჯოინის და DISTINCT-ის გამოყენების გარეშე
--გვეტყვის ვის გააჩნია დეპოსიტებიც და სესხებიც.

SELECT*FROM Customers AS C
WHERE C.CustomerID IN(SELECT CustomerID FROM Deposits)
OR C.CustomerID IN (SELECT CustomerID FROM loan.Loans) 
--თუ ორივე ცხრილში ერთდროულად მეორდება მომხმარებლის აიდი მაშინ გამოდის რომ მას აქვს სესხიც და დეპოზიტიც.



--9. რატომ სელექთდება 18 ჩანაწერი.

SELECT * FROM loan.Loans as l 
JOIN Deposits as d
ON l.CustomerID = d.CustomerID
WHERE l.CustomerID = 115

SELECT * FROM loan.LOANS AS L
WHERE L.CustomerID=115
-- ამ მომხმარებელს აქვს 9 სესხი

SELECT*FROM DEPOSITS AS D
WHERE D.CustomerID=115
-- და 2 დეპოზიტი,
--ჯოინის დროს თითოეული სესხი დაწყვილდება 2-2 ცალ დეპოზიტთან
-- და მივიღებთ ასეთ 18 კომბინაციას
-- მოკლედ რომ ვთქვათ მონაცემები დუბლირდება
--ცხრავე სესხისთვის მართებულია პირობა რომ ამ მომხმარებლმა გააკეთა პირველი დეპოზიტი
--და ასე იქნება მეორე დეპიზიტისთვისაც.
--ამით შეგვიძლია დავადგინოთ , რომ სესხებსა და დეპოზიტებს შორის კავშირი არის მრავალი-მრავალთან